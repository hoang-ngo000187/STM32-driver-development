/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/* RCC Base address */
#define RCC_BASE_ADDR			0x40023800UL
/* GPIOA Base address */
#define GPIOA_BASE_ADDR			0x40020000UL

/* Address for RCC_CFGR */
#define RCC_CFGR_OFFSET			0x08UL
#define RCC_CFGR_ADDR			(RCC_BASE_ADDR + RCC_CFGR_OFFSET)

/* Address for RCC AHB1 peripheral clock register (RCC_AHB1ENR) */
#define RCC_AHB1ENR_OFFSET		0x30UL
#define RCC_AHB1ENR_ADDR		(RCC_BASE_ADDR + RCC_AHB1ENR_OFFSET)

/* Address for GPIO port mode register (GPIOA_MODER) */
#define GPIOA_MODER_OFFSET		0x00UL
#define GPIOA_MODER_ADDR		(GPIOA_BASE_ADDR + GPIOA_MODER_OFFSET)

/* Address for GPIO alternate function high register (GPIOA_AFRH) */
#define GPIOA_AFRH_OFFSET		0x24UL
#define GPIOA_AFRH_ADDR			(GPIOA_BASE_ADDR + GPIOA_AFRH_OFFSET)

int main(void)
{
	uint32_t *pRccCfgrReg = (uint32_t *)(RCC_CFGR_ADDR);
	

	/* 01) Clear bit 21th and 22th to select HSI clock source for MCO1 signal */
	*pRccCfgrReg &= ~(0x3 << 21);

	/* Configure MCO1 prescaler: divide HSI clock by 4: Bit 26 - Bit 25 - Bit 24 <=> 1 1 0 */
	*pRccCfgrReg |= (1 << 25);
	*pRccCfgrReg |= (1 << 26);


	/* 02) Configure PA8 to AF0 mode to behave as MCO1 signal */

		/* a) Enable clock for GPIOA by setting bit 0th of RCC_AHB1ENR register */	
	uint32_t *pRccAhb1EnrReg = (uint32_t *)(RCC_AHB1ENR_ADDR);
	*pRccAhb1EnrReg |= (1 << 0);

		/* b) Configure the mode of GPIOA pin 8 as alternative function mode */
	uint32_t *pGPIOAModerReg = (uint32_t *)(GPIOA_MODER_ADDR);
	*pGPIOAModerReg &= ~(0x3 << 16); // First, clear 2 bits: 16th and 17th
	*pGPIOAModerReg |= (0x2 << 16); // Then, set 2 bits 17th_16th = 10b (Alternative function mode)

		/* c) Configure the alternative function register to set the mode 0 for PA8 */
	uint32_t *pGPIOAAltFuncHighReg = (uint32_t *)(GPIOA_AFRH_ADDR);
	*pGPIOAAltFuncHighReg &= ~(0xf << 0); // 0xf <=> 1111b

    /* Loop forever */
	for(;;);
}
